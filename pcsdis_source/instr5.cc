#include "instr.h"
#include "segment.h"
#include "exprfactory.h"

/*
 * These are instructions that are not generated by the compiler
 * (NonCCxxxInstr)
 */

NCCctor(Ccr)
{
	arg1 = new NumArg(low(uword()), "#");
	arg2 = cpureg(CCR);
}

NCCctor(Sr)
{
	arg1 = new NumArg(uword(), "#");
	arg2 = cpureg(SR);
}

NCCctor(Rtm)
{
	arg1 = new XnArg(opcode, OPWnone, 1);
}

NCCctor(Callm)
{
	arg1 = new NumArg(low(uword()), "#");
	arg2 = ea(opcode);
}

NCCctor(CmpChk2)
{
	int extw = uword();
	width = width109();

	opstr = op11(extw) ? "chk2" : "cmp2";
	opstr += LField(width);
	
	arg1 = new XnArg(r15(extw), OPWnone, 1);
	arg2 = ea(opcode);
}

NCCctor(Moves)
{
	width = width67();
	opstr += LField(width);
	int extw = uword();
	arg1 = ea(opcode);
	arg2 = new XnArg(r15(extw), OPWnone, 1);
	swapargs(dir11(extw));
}

Cas2Instr::Cas2Instr(Item op)
	: _Instr(op)
{
	width = width109();
	opstr += LField(width);
	
	int extw1 = uword();
	int extw2 = uword();
	arg1 = new RegArg(rx(extw1), REGdata);
	arg2 = new RegArg(rx(extw2), REGdata);
	arg3 = new RegArg(r8(extw1), REGdata);
	arg4 = new RegArg(r8(extw2), REGdata);
	arg5 = new XnArg(r15(extw1), OPWnone, 1);
	arg6 = new XnArg(r15(extw2), OPWnone, 1);
}

cString Cas2Instr::toAsmString() const
{
	String astr(opstr);
	astr += "\t";
	astr += arg1->toAsmString();	// first register pair
	astr += ":";
	astr += arg2->toAsmString();
	astr += ", ";
	astr += arg3->toAsmString();	// second register pair
	astr += ":";
	astr += arg4->toAsmString();
	astr += ", (";
	astr += arg5->toAsmString();	// third register pair
	astr += "):(";
	astr += arg6->toAsmString();
	astr += ")";
	return astr;
}

NCCctor(Cas)
{
	int extw = uword();
	arg1 = new RegArg(rx(extw), REGdata);
	arg2 = new RegArg(r8(extw), REGdata);
	arg3 = ea(opcode);
}

NCCctor(Bitd)
{
	arg1 = new RegArg(ry(), REGdata);
	arg2 = ea(opcode);
}

NCCctor(Movep)
{
	width = width6();
	opstr += LField(width);
	
	arg1 = new Aidx2Arg(rx(), uword());
	arg2 = new RegArg(ry(), REGdata);
	swapargs(dir7());
}

NCCctor(MoveSR0)
{
	arg1 = cpureg(SR);
	arg2 = ea(opcode);
}

NCCctor(MoveSR1)
{
	arg2 = cpureg(SR);
	arg1 = ea(opcode);
}

NCCctor(MoveCCR0)
{
	arg1 = cpureg(CCR);
	arg2 = ea(opcode);
}

NCCctor(MoveCCR1)
{
	arg2 = cpureg(CCR);
	arg1 = ea(opcode);
}

NCCctor(Swap)
{
	arg1 = new RegArg(rx(), REGdata);
}

NCCctor(Bkpt)
{
	arg1 = new NumArg(rx(), "#");
}

NCCctor(Trap)
{
	arg1 = new NumArg(opcode & 0xf, "#");
}

NCCctor(MoveUsp)
{
	arg1 = new RegArg(rx(), REGptr);
	arg2 = cpureg(USP);
	swapargs(dir7());
}

NCCctor(Movec)
{
	int extw = uword();
	arg1 = new XnArg(r15(extw), OPWnone, 1);
	arg2 = cpureg(extw);
	swapargs(dir0());
}

NCCctor(Chk)
{
	width = width67();
	opstr += LField(width);
	arg1 = ea(opcode);
	arg2 = new RegArg(ry(), REGdata);
}

NCCctor(BcdX0)
{
	width = OPWbyte;
	
	if (RM()) {
		arg1 = new ApdArg(rx());
		arg2 = new ApdArg(ry());
	} else {
		arg1 = new RegArg(rx(), REGdata);
		arg2 = new RegArg(ry(), REGdata);
	}
}

NCCctor(BcdX1)
{
	width = width67();
	opstr += LField(width);
	
	if (RM()) {
		arg1 = new ApdArg(rx());
		arg2 = new ApdArg(ry());
	} else {
		arg1 = new RegArg(rx(), REGdata);
		arg2 = new RegArg(ry(), REGdata);
	}
}

NCCctor(Bcd3)
{
	width = width67();
	opstr += LField(width);
	
	if (RM()) {
		arg1 = new ApdArg(rx());
		arg2 = new ApdArg(ry());
	} else {
		arg1 = new RegArg(rx(), REGdata);
		arg2 = new RegArg(ry(), REGdata);
	}
}

NCCctor(Cmpm)
{
	width = width67();
	opstr += LField(width);

	arg1 = new ApiArg(rx());
	arg2 = new ApiArg(ry());
}

NCCctor(Exg)
{
	int opm = opcode & 0xc8;
	if (opm == 0x40) {
		arg1 = new RegArg(ry(), REGdata);
		arg2 = new RegArg(rx(), REGdata);
	} else if (opm == 0x48) {
		arg1 = new RegArg(ry(), REGptr);
		arg2 = new RegArg(rx(), REGptr);
	} else if (opm == 0x88) {
		arg1 = new RegArg(ry(), REGdata);
		arg2 = new RegArg(rx(), REGptr);
	} else
		FATALERROR("Invalid EXG instr=" + std::to_string(opcode));
}
