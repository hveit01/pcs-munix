/*PCS specific */
#include <sys/types.h>
#include <sys/param.h>
#include <sys/sw.h>

static char *_Version = "@(#) RELEASE:  2.1 Mar 20 1987 /usr/sys/startup/swctrl.c ";
extern char tbf[];
char *sw_buf = tbf;
struct {
    short ncyl;
    short nhead;
    short nsec;
} drivedata;
#define SECPERCYL (drivedata.nhead * drivedata.nsec)
#define TOTALSECS  (drivedata.ncyl * drivedata.nhead * drivedata.nsec)


struct sw_badblockinfo badblkinfo;
short sw_brutto;
int sw_bruttobytes;
short atleast_one_entry;
short standardinput;
short retain_nl;
short formatdone;
short badscandone;
struct swtyp {
    char* name;
    short ncyl;
    short nhead;
    short nsec;
    char  drvpar1;
    char  drvpar2;
    char  drvpar3;
    char  drvpar4;
    short brutto;
    long bruttobytes;
} swtyp[] = {
    { "WD81 - Fujitsu M2312,  84MB (589 Cyl,  7 Heads, 32 Sectors)",
      589, 7,  32, 8,  0,  0,   17, 640, 20480 },
    { "WD82 - Fujitsu M2322, 168MB (823 Cyl, 10 Heads, 32 Sectors)",
      823, 10, 32, 10, 0,  0,   16, 639, 20480 },
    { "WD83 - Fujitsu M2333, 337MB (823 Cyl, 10 Heads, 65 Sectors)",
      823, 10, 65, 26, 2,  128, 18, 632, 40960 },
    { "WD84 - Fujitsu M2344, 690MB (624 Cyl, 27 Heads, 65 Sectors)",
      624, 27, 65, 26, 2,  128, 21, 629, 40960 },
    { "WD41 - Fujitsu M2351, 474MB (842 Cyl, 20 Heads, 46 Sectors)",
      842, 20, 46, 26, 2,  0,   19, 612, 28160 },
    { "WD42 - Fujitsu M2361, 689MB (842 Cyl, 20 Heads, 65 Sectors)",
      842, 20, 65, 26, 2,  128, 20, 630, 40960 },
    { "CDC/DIETZ, 80MB (823 Cyl, 5 Heads, 32 Sectors)",
      823, 5,  32, 8,  12, 0,   22, 630, 20160 },
    { 0,   0,  0,  0,  0,  0,   0,  0,   0 }
};

struct xlat {
    int cyl, head, boff, blen;
} media, trans;
int glbsec;
int nettosecs;
int iflag;
int rsw;

char eeprom[] = {
  0x3e, 0x00, 0x10, 0xac, 0x00, 0x00, 0x00, 0x00, 0x28, 0x28, 0x02, 0xa2, 0xa2, 0x7a, 0x7a, 0x7a,
  0x00, 0x00, 0x8c, 0x0c, 0x0c, 0x81, 0x81, 0x81, 0x17, 0x17, 0x14, 0x14, 0x14, 0x14, 0x14, 0x17,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04,
  0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x20,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 0x10, 0x02, 0x00, 0x00, 0x03, 0x03, 0x04,
  0x01, 0x03, 0x05, 0x07, 0x09, 0x0b, 0x0d, 0x0f, 0x11, 0x13, 0x15, 0x17, 0x19, 0x1b, 0x1d, 0x1f,
  0x21, 0x23, 0x25, 0x27, 0x29, 0x2b, 0x2d, 0x2f, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e,
  0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x2e, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x20, 0x20, 0x41, 0x2e, 0x41, 0x41, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x14, 0x13, 0x05, 0x05, 0x13, 0x10, 0x02, 0x02, 0x28, 0x05, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0a, 0x07, 0x0a, 0x14, 0x14, 0x1b, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x4a, 0x37, 0x37, 0x37, 0x37, 0x00, 0x37, 0x70, 0x4b, 0x6e, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x37, 0x4d, 0x37, 0x4a, 0x4a, 0x70, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x03, 0x02, 0x03, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x03, 0x02, 0x03, 0x03, 0x03, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x2e, 0x20, 0x20, 0x2e, 0x2e, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x20, 0x20, 0x41, 0x2e, 0x41, 0x41, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x14, 0x13, 0x07, 0x14, 0x14, 0x10, 0x02, 0x02, 0x28, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0a, 0x07, 0x0a, 0x14, 0x14, 0x1b, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x94, 0x94, 0x94, 0x94, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  'S',  'W',  0xc6, 0x15, 0x00, 0x10, 0x03, 0x0a, 0xc2, 0x15, 0x00, 0x08, 0xdf, 0x10, 0x50, 0xff,
  0xf7, 0x09, 0x12, 0x00, 0xc7, 0x15, 0x18, 0x08, 0x83, 0x0a, 0xdf, 0x10, 0x50, 0xff, 0xf7, 0x09,
  0x04, 0x00, 0xc7, 0x15, 0x36, 0x08, 0xc0, 0x15, 0x00, 0x01, 0xc1, 0x15, 0x00, 0xf6, 0x52, 0x14,
  0xc0, 0x0a, 0xfd, 0x02, 0x87, 0x00, 0xc6, 0x15, 0x00, 0x08, 0xc1, 0x15, 0x7e, 0x08, 0xf7, 0x09,
  0xdc, 0x00, 0xc1, 0x15, 0xa3, 0x08, 0xf7, 0x09, 0xd4, 0x00, 0xc2, 0x15, 0x74, 0x08, 0xf7, 0x09,
  0xa6, 0x00, 0xf7, 0x87, 0xc2, 0xe5, 0x74, 0x08, 0xc2, 0x65, 0x7a, 0x08, 0xa6, 0x10, 0xf7, 0x09,
  0x64, 0x00, 0xef, 0x87, 0xc0, 0x15, 0x3a, 0x00, 0xf7, 0x09, 0xd2, 0x00, 0xf7, 0x09, 0xde, 0x00,
  0x00, 0x0a, 0x87, 0x12, 'S',  'M',  'B',  'D',  0x00, 0x00, 0x56, 0x09, 0xf8, 0x09, '\r', '\n',
  'S',  'p',  'e',  'c',  't',  'r',  'a',  '-',  '2',  '5',  ' ',  'b',  'o',  'o',  't',  ' ',
  'P',  'r',  'o',  'm',  '.',  ' ',  ' ',  '9',  '-',  'N',  'O',  'V',  '-',  '1',  '9',  '8',
  '3',  '.',  0x00, '\r', '\n', 'P',  'l',  'e',  'a',  's',  'e',  ' ',  'p',  'i',  'c',  'k',
  ' ',  'b',  'o',  'o',  't',  ' ',  't',  'y',  'p',  'e',   '.', '\r', '\n', 'M',  'S',  ',',
  'D',  'B',  ' ',  '>',  ' ',  0x00, 0x05, 0x0a, 0xf7, 0x09, 0x62, 0x00, 0x17, 0xa0, 0x0d, 0x00,
  0x0f, 0x03, 0xf7, 0x09, 0x68, 0x00, 0x17, 0xa0, 0x30, 0x00, 0x0c, 0x05, 0x17, 0xa0, 0x37, 0x00,
  0x09, 0x06, 0xc5, 0x0c, 0xc5, 0x0c, 0xc5, 0x0c, 0xc0, 0xe5, 0x30, 0x00, 0x05, 0x60, 0xec, 0x01,
  0xa1, 0x00, 0x87, 0x00, 0xb1, 0x00, 0x87, 0x00, 0xf7, 0x09, 0x32, 0x00, 0xf7, 0x09, 0x3e, 0x00,
  0xc0, 0x00, 0x01, 0x10, 0xf7, 0x09, 0x26, 0x00, 0xf7, 0x09, 0x32, 0x00, 0x40, 0x50, 0xa1, 0x00,  
  0x80, 0x22, 0x04, 0x03, 0x97, 0x24, 0x00, 0x00, 0xfb, 0x02, 0xb1, 0x00, 0x87, 0x00, 0x26, 0x10,
  0x40, 0x94, 0x03, 0x03, 0xf7, 0x09, 0x16, 0x00, 0xfb, 0x01, 0x80, 0x15, 0x87, 0x00, 0xdf, 0x8b,
  0x70, 0xff, 0xfd, 0x80, 0xc0, 0x97, 0x72, 0xff, 0xc0, 0x45, 0x80, 0xff, 0x87, 0x00, 0xdf, 0x8b, 
  0x74, 0xff, 0xfd, 0x80, 0xc0, 0x45, 0x80, 0xff, 0x1f, 0x90, 0x76, 0xff, 0x87, 0x00, 0xdf, 0x8b,
  0x74, 0xff, 0xfd, 0x80, 0x87, 0x00, 0xc1, 0x15, 0x52, 0xf5, 0xc9, 0x8b, 0xfe, 0x80, 0xe1, 0x15,
  0xd8, 0x09, 0xf1, 0x8b, 0x02, 0x00, 0xfd, 0x80, 0xdf, 0x0b, 0xec, 0x09, 0x02, 0x81, 0x77, 0x00,
  0x8e, 0xfe, 0xf1, 0x35, 0x00, 0x04, 0x02, 0x00, 0x03, 0x03, 0x05, 0x00, 0x77, 0x00, 0x80, 0xfe,
  0x1f, 0x0a, 0xec, 0x09, 0xc9, 0x15, 0xe8, 0x09, 0xf1, 0x8b, 0x02, 0x00, 0xfd, 0x80, 0xdf, 0x0b, 
  0xec, 0x09, 0xf8, 0x80, 0xdf, 0x35, 0x02, 0x00, 0xec, 0x09, 0x03, 0x03, 0x05, 0x00, 0x77, 0x00,
  0x5e, 0xfe, 0xc9, 0x15, 0xe0, 0x09, 0xf1, 0x8b, 0x02, 0x00, 0xfd, 0x80, 0xdf, 0x0b, 0xec, 0x09,
  0xf8, 0x80, 0xdf, 0x35, 0x02, 0x00, 0xec, 0x09, 0x03, 0x03, 0x05, 0x00, 0x77, 0x00, 0x40, 0xfe,
  0xd1, 0x0b, 0xc4, 0x15, 0x84, 0x08, 0x00, 0x0a, 0x07, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xec, 0x09, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x04, 0xc0, 0xd0, 0x09, 0x00, 0x00, 0x08, 0x00,
  0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x08, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x15, 0xc0, 0xfd, 0x71, 0x11, 0x08, 0x00,
  0xc9, 0x15, 0x11, 0x00, 0xf1, 0x15, 0x00, 0x10, 0x1a, 0x00, 0x71, 0x1c, 0x0e, 0x00, 0x0e, 0x00,
  0xf1, 0x15, 0x00, 0xfe, 0x02, 0x00, 0xf1, 0x15, 0x00, 0x00, 0x04, 0x00, 0xc9, 0x15, 0x39, 0x00,
  0xc9, 0x8b, 0xfe, 0x80, 0xc9, 0x0b, 0x02, 0x80, 0x05, 0x00, 0xe6, 0x01, 0x40, 0x11, 0x07, 0x0a,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };


swctrl1(unused, unit)
int unused;
int unit;
{
    char *name;

    switch (unit) {
    case 0:
        name = "SW(15)";
        break;
    case 1:
        name = "SW(31)";
        break;
    default:
        printf("invalid unit\n");
        return 0;
    }
    
    swctrl(name);
    return 0;
}

swctrl2(unused, unit)
int unused;
int unit;
{
    char *name;

    switch (unit) {
    case 0:
        name = "SW2(15)";
        break;
    case 1:
        name = "SW2(31)";
        break;
    default:
        printf("invalid unit\n");
        return 0;
    }
    
    swctrl(name);
    return 0;
}

swctrl(line)
char *line;
{
    int secno;
    
    if ((rsw = sa_open(line, 2)) < 0) {
        printf("Fatal - cannot open %s\n", line);
        return -1;
    }

    iflag = 0;
    if (getdrivedata() == 0) {
        printf("Ignore old bad sector info (if present) ? (y/n) : ");
        iflag = getyes();
        printf("Do you want to format the drive ? (y/n) : ");
        if (getyes()) {
            if (getbadblkinfo() != 0) goto done;
            if (formatdrive() != 0) goto done;
        }
        if (formatdone == 0 && iflag) {
            iflag = 0;
            if (getbadblkinfo() != 0) goto done;
            validate();
            iflag++;
        }
        if (getbadblkinfo() != 0) goto done;

        printf("Do you want a bad sector scan ? (y/n) : ");
        if (getyes()) {
            if (badblkscan(0)) goto done;
            badscandone++;
        } else if (formatdone) {
            if (badblkscan(1)) goto done;
        }

        printf("Do you want to enter the media defect list onto disk? (y/n) : ");
        if (getyes()) {
            if (formatdone==0 && badscandone==0 && iflag)
                if (badblkscan(1)) goto done;
            iflag = 0;
            if (getbadblkinfo()) goto done;
            readlist(0);
        }
        goto done;
        
        /* DEADCODE */
        if (getbadblkinfo() == 0) {
            printf("enter sector number (decimal) : ");
            gets(line);
            secno = atol(line);
            if (secno < 0 || secno > nettosecs) goto done;
            swbadfix(secno);
        }
        /*DEADCODE*/
    }
    
done:
    sa_close(rsw);
    return 1;
}

getdrivedata()
{
    int i;

    if (sa_ioctl(rsw, SW_GETCONF, &drivedata) < 0) {
        printf("Fatal - cannot get drive characteristics\n");
        return -1;
    }

    printf("Drive has %d cylinders, %d tracks per cylinder, and %d sectors per track\n",
        drivedata.ncyl, drivedata.nhead, drivedata.nsec);
    printf("Total capacity [in Megabytes]: %d Mbytes\n", TOTALSECS / (2*1024));
    nettosecs = TOTALSECS;
    nettosecs -= 212;

    for (i=0; swtyp[i].name; i++) {
        if (drivedata.ncyl == swtyp[i].ncyl &&
            drivedata.nhead == swtyp[i].nhead &&
            drivedata.nsec == swtyp[i].nsec) break;
    }
    if (i==8) {
        printf("Fatal: unknown disk type\n");
        return 0;
    }

    sw_brutto = swtyp[i].brutto;
    sw_bruttobytes = swtyp[i].bruttobytes;
    return 0;
}

formatdrive()
{
    int i;

    printf("All data on drive will be lost ! Continue ? (y/n) : ");
    if (getyes() == 0)
        return -1;
    
    printf("Formatting in progress - wait ca. 7 min. ...\n");
    if (sa_ioctl(rsw, SW_FORMAT, 0) < 0) {
        printf("Fatal - cannot format drive\n");
        return -1;
    }

    printf("... Formatting completed\n");
    if (iflag == 0) {
        for (i=0; i < MAXBADSEC; i++) {
            if (badblkinfo.sw_log_bad[i])
                sa_ioctl(rsw, SW_HDRINVAL, &badblkinfo.sw_log_bad[i]);
        }
    }

    if (putbadblkinfo())
        printf("Fatal - cannot write bad sector info to formatted disk\n");

    formatdone++;
    return 0;
}

badblkscan(flag)
int flag;
{
    register int i;
    register int altsec;
    register int n;
    int wrt;
    int j, k, nbad, bad;

    if (sa_ioctl(rsw, SW_NORETRY_AND_ECC, 0) < 0) {
        printf("FATAL - cannot set bad sector scan condition\n");
        return -1;
    }
    
    if (flag==0) {
        if (iflag) {
            printf("May the bad sector scan write on the disk ?\n");
            printf("(Writing improves the scan, but destroys all data) (y/n) : ");
            wrt = getyes();
        } else {
            for (i=0; i < 127; i++) {
                if (badblkinfo.sw_log_bad[i])
                    sa_ioctl(rsw, SW_HDRINVAL, &badblkinfo.sw_log_bad[i]);
            }
            if (putbadblkinfo())
                return -1;
            printf("May the bad sector scan write on the disk ?\n");
            printf("(Writing improves the scan, but destroys all data) (y/n) : ");
            wrt = getyes();
        }
    }
    
    if (iflag || flag) {
        if (flag == 0)
            printf("Bad sector scan of alternate sectors in Progress ...\n");

        altsec = TOTALSECS;
        altsec -= 3;
        
        for (i=0; i < MAXBADSEC; i++) {
            do {
                sa_lseek(rsw, altsec * 512, 0);
                n = sa_transfer(rsw, sw_buf, 512, 0, 1);
                if (n != 512)
                    printf("Bad alternate sector %ld/0x%lx found - ok!\n", altsec, altsec);
                altsec--;
            } while (n != 512 && altsec > nettosecs);
            if (altsec <= nettosecs) {
                printf("Could only obtain %ld alternate sectors - ok!\n", i);
                break;
            } else 
                badblkinfo.sw_log_alter[i] = altsec;
        }
    }

    if (flag == 0) {
        printf("Bad sector scan of common sectors in progress - wait ca. 20 min ... \n");
        for (altsec = 0; altsec < nettosecs; altsec += i) {
            if ((altsec + (i = drivedata.nsec)) > nettosecs)
                i = nettosecs - altsec;
            if (wrt) {
                fillbuf(sw_buf, i * 512);
                sa_lseek(rsw, altsec*512, 0);
                sa_transfer(rsw, sw_buf, i * 512, 1, 1);
            }
            sa_lseek(rsw, altsec*512, 0);
            n = sa_transfer(rsw, sw_buf, i * 512, 0, 1);
            if (n != (i*512)) {
                for (k = 0, nbad = 0; k++ < 5 && nbad==0; ) {
                    for (j = 0; j < i; j++) {
                        sa_lseek(rsw, (altsec + j) * 512, 0);
                        n = sa_transfer(rsw, sw_buf, 512, 0, 1);
                        if (n != 512) {
                            translate(altsec + j);
                            printf("Bad sector %7ld/0x%-07lx \n(cyl: %4d  head: %2d  first byte: %6ld  last byte: %6ld) found - \n",
                                altsec + j, altsec + j, trans.cyl, trans.head, trans.boff, trans.blen);

                            /* find a replacement for defective sector */
replace:                    for (bad = 0; bad < MAXBADSEC && 
                                badblkinfo.sw_log_bad[bad] != (altsec + j) && 
                                (badblkinfo.sw_log_alter[bad] == 0 || badblkinfo.sw_log_bad[bad] != 0); bad++);
                            nbad++;
                            if (bad >= MAXBADSEC) {
                                printf("Fatal - too many bad sectors\n");
                                return -1;
                            }
                            if (badblkinfo.sw_log_bad[bad] == (altsec + j)) {
                                printf("Warning: alternate sector bad as well\n");
                                badblkinfo.sw_log_bad[bad] = 0;
                                badblkinfo.sw_log_alter[bad] = 0;   /* mark alternate as unusable */
                                /* try to find a new replacement */
                                goto replace;
                            }
                            glbsec = altsec + j;
                            if (sa_ioctl(rsw, SW_HDRINVAL, &glbsec) < 0)
                                printf("Warning - cannot invalidate header of sector %ld/0x%lx\n", glbsec, glbsec);
                            badblkinfo.sw_log_bad[bad] = altsec + j;
                            printf("Replacement sector is %ld/0x%lx\n", badblkinfo.sw_log_alter[bad], badblkinfo.sw_log_alter[bad]);
                        }
                    }
                }
            }
        }
        printf("Bad sector scan completed\n");
    }
    if (putbadblkinfo())
        return -1;
    
    if (sa_ioctl(rsw, SW_REINIT, 0) < 0) {
        printf("Fatal- cannot reinitialize drive\n");
        return -1;
    }

    return 0;
}

fillbuf(buf, size)
register int *buf;
{
    register char *endp = (char*)buf + size;

    while (buf < (int*)endp)
        *buf++ = 0xeb6db6db;    /* fill pattern */
}

int getbadblkinfo()
{
    register int i;
    if (iflag != 0 || 
       (iflag == 0 && (sa_ioctl(rsw, SW_READBAD, &badblkinfo) < 0 || badblkinfo.sw_magic != SWMAGIC))) {

        if (iflag == 0) {
            printf("Unreadable drive bad block info. Ignore ? (y/n) : ");
            if (getyes() == 0)
                return -1;
        }
        iflag++;
        badblkinfo.sw_magic = SWMAGIC;
        for (i = 0; i < MAXBADSEC; i++) {
            badblkinfo.sw_log_bad[i] = 0;
            badblkinfo.sw_log_alter[i] = 0;
        }
    }
    return 0;
}

putbadblkinfo()
{
    if (sa_ioctl(rsw, SW_WRITEBAD, (caddr_t)&badblkinfo) < 0) {
        printf("Fatal - cannot write bad block info to disk !\n");
        return -1;
    }
    return 0;
}

getyes()
{
    register int i;
    char buf[80];

    gets(buf);
    for (i = 0; i < 80 && buf[i]==' '; i++);
    if (buf[i]=='y' || buf[i]=='Y' || buf[i]=='j' || buf[i]=='J')
        return 1;
    else return 0;
}

static int physsec;

swbadfix(secno)
int secno;
{
    register int i;

    physsec = secno;
    
    for (i = 0; i < MAXBADSEC; i++) {
        if (badblkinfo.sw_log_bad[i] == secno) {
            physsec = badblkinfo.sw_log_alter[i];
            break;
        }
    }

    if (sa_ioctl(rsw, SW_NORETRY_AND_ECC, 0) < 0) {
        printf("Cannot set special IO condition\n");
        return -1;
    }

    printf("first validate header of ill sector ...\n");
    if (sa_ioctl(rsw, SW_HDRVAL, &physsec) < 0) {
        printf("Cannot validate sector header - Sector is bad\n");
    } else {
        printf("... header validation succeed - read sector ...\n");
        sa_lseek(rsw, secno * 512 , 0);
        if (sa_transfer(rsw, sw_buf, 512, 0, 1) != 512)
            printf("... sector could not be read properly\n");
        else {
            printf("... sector could be read properly\n");
            printf(" do you want to continue in spite of success ? (y/n) : ");
            if (getyes() == 0) goto done;
        }

        sa_lseek(rsw, secno * 512, 0);
        if (sa_transfer(rsw, sw_buf, 512, 1, 1) != 512)
            printf("... sector could not be written properly\n");
        else {
            printf("... sector could be written properly ...\n");
            printf("test-reading sector ...\n");
            sa_lseek(rsw, secno * 512, 0);
            if (sa_transfer(rsw, sw_buf, 512, 0, 1) != 512) {
                printf("... sector remains is bad\n");
                printf(" do you want to mark the sector as bad ? (y/n) : ");
                if (getyes() == 0) goto fsck;
            } else {
                printf("... sector seems to be good now !\n");
                printf(" do you want to mark the sector in spite of success ? (y/n) : ");
                if (getyes() == 1) goto enterbad;
                else goto fsck;
            }
        }
    }

enterbad:
    if (secno != physsec)
        printf("Fatal - examined sector already in bad block list !\n");
    else {
        for (i = 0; i < MAXBADSEC; i++) {
            if (badblkinfo.sw_log_bad[i]==0 && badblkinfo.sw_log_alter[i]!=0)
                break;
        }
        if (i >= MAXBADSEC)
            printf("Fatal: too many bad sectors\n");
        else {
            sa_ioctl(rsw, SW_HDRINVAL, &physsec);
            physsec = badblkinfo.sw_log_alter[i];
            badblkinfo.sw_log_bad[i] = secno;
            putbadblkinfo();
            printf("sector entered in bad sector info, alternate sector is %ld/0x%lx\n",
                physsec, physsec);
            printf("Try to save contents to alternate sector\n");
            sa_lseek(rsw, secno*512, 0);
            if (sa_transfer(rsw, sw_buf, 512, 1, 1) != 512)
                printf("... Sector contents could not be saved properly\n");
            else
                printf("... Sector contents could be saved on alternate sector.\n");
fsck:
            printf("Please run a 'fsck' for all file systems on the disk.\n");
        }
    }
done:
    delay(50);
    sa_ioctl(rsw, SW_REINIT, 0);
    return 0;
}

struct {
    short addr;
    short data;
} swctl;

sweeprom()
{
    register int i, fd;
    char ln[80];
    int k, typ;

    printf("Is the controller the first SP15, SP25 (or RM) in the system ? (y/n) : ");
    if (getyes() == 0) {
        fd = sa_open("sw2(15)", 2);
        eeprom[3] = 0xf8;
    } else {
        fd = sa_open("sw(15)", 2);
        eeprom[3] = 0xac;
    }
    
    if (fd < 0) {
        printf("cannot open device. device must be\n");
        printf("sw(15) for first or sw2(15) for second controller\n");
        return -1;
    }

    printf("Does the memory allow block mode DMA ? (y/n) : ");
    if (getyes())
        eeprom[4] = 0x80;


    for (k = 0; k < 2; k++) {
        for (;;) {
            printf("select drive type for drive #%d\n", k);
            for (i = 0; swtyp[i].name != 0; i++)
                printf("\t%d: %s\n", i, swtyp[i].name);
            printf("choose number [0..%d] : ", i - 1);
            gets(ln);
            typ = atol(ln);
            if (typ >= 0 && typ <= (i-1))
                break;
            printf("wrong input - try again\n");
        }
        
        eeprom[8+k] = swtyp[typ].drvpar1;
        eeprom[16+k] = swtyp[typ].drvpar2;
        eeprom[40+k] = swtyp[typ].drvpar3 + k;
        eeprom[72+k] = swtyp[typ].drvpar4;
    }

    for (i = 0; i < 2048; i++) {
        swctl.addr = i;
        if (sa_ioctl(fd, SW_REEPROM, &swctl) < 0) {
            printf("cannot read eeprom\n");
            goto done;
        }
        
        if (swctl.data != (eeprom[i] & 0xff)) {
            printf("byte %4d old %02x new %02x\n", i, swctl.data, eeprom[i] & 0xff);
            swctl.data = eeprom[i] & 0xff;
            if (sa_ioctl(fd, SW_WEEPROM, &swctl) < 0) {
                printf("cannot write eeprom\n");
                goto done;
            }
            swctl.addr = i;
            sa_ioctl(fd, SW_REEPROM, &swctl);
            if (swctl.data != (eeprom[i] & 0xff)) {
                printf("cannot write eeprom\n");
                goto done;
            }
        }
    }

    printf("EEPROM reprogramed successfully\n");
    sa_ioctl(fd, SW_RSTPROM, &swctl);
    sa_ioctl(fd, SW_CONTRINIT, &swctl);
    sa_ioctl(fd, SW_REINIT, &swctl);

done:
    sa_close(fd);
}

static int readlist(flag)
int flag;
{
    int eof, secno;
    int nb0, nbytes, nsec;
    static char ln[80];

    printf("Enter media defect list (cylinder head byteoffset bitlength).\nEmpty line terminates input.\n");

loop:
    ln[0] = ln[1] = ln[2] = '\0';
       gets(ln);
       eof = scanline(ln);
    if (eof == -1) {
        printf("WARNING: incorrect input (ignored): %s", ln);
        if (retain_nl == 0)
            printf("\n");
        goto loop;
    }
    if (eof != 0) {
        if ((secno = checkinput(media.cyl, media.head, media.boff, media.blen, ln)) && !flag) {
            nbytes = media.blen / 8;
            if (media.blen % 8)
                nbytes++;
            if ((nbytes % sw_brutto) == 0)
                nbytes--;
        
            nb0 = nbytes;
            nbytes /= sw_brutto;
            if (extend(nb0) != 0)
                nbytes++;

            nsec = 0;
            do {
                swmediafix(secno + nsec, ln);
                nsec++;
            } while (nbytes-- != 0);
        }
        goto loop;
    }
    if (flag)
        return 0;
    

    putbadblkinfo();
    sa_ioctl(rsw, SW_REINIT, 0);
    return 0;
}

int checkinput(cyl, head, boff, blen, ln)
int cyl, head, boff, blen;
char *ln;
{
    int secno;

    if (cyl < 0 || cyl >= drivedata.ncyl) {
        printf("WARNING: incorrect input (ignored): %s", ln);
        if (retain_nl == 0)
            printf("\n");
        return 0;
    }

    if (head < 0 || head >= drivedata.nhead) {
        printf("WARNING: incorrect input (ignored): %s", ln);
        if (retain_nl == 0)
            printf("\n");
        return 0;
    }
    
    if (boff < 0 || boff > sw_bruttobytes) {
        printf("WARNING: incorrect input (ignored): %s", ln);
        if (retain_nl == 0)
            printf("\n");
        return 0;
    }
    
    if (blen < 8) {
        printf("WARNING: incorrect input (ignored): %s", ln);
        if (retain_nl == 0)
            printf("\n");
        return 0;
    }

    secno = boff / sw_brutto;
    secno += (drivedata.nhead * cyl + head) * drivedata.nsec;
    secno -= 2;
    if (secno < 0)
        printf("WARNING: physical blocks number 0 and 1 cannot be marked as bad (ignored).\n");

    return secno < 0 ? 0 : secno;
}

swmediafix(secno, dummy)
int secno;
char *dummy;
{
    int i;

    for (i = 0; i < MAXBADSEC; i++) {
        if (badblkinfo.sw_log_bad[i] == secno) {
            printf("Fatal - examined sector already in bad block list !\n");
            return -1;
        }
        if (badblkinfo.sw_log_bad[i] == 0 && badblkinfo.sw_log_alter[i] != 0)
            break;
    }

    if (sa_ioctl(rsw, SW_NORETRY_AND_ECC, 0) < 0) {
        printf("Cannot set special IO condition\n");
        return -1;
    }

    if (i >= MAXBADSEC) {
        printf("Fatal: too many bad sectors.\n");
        return -1;
    }
    
    sa_ioctl(rsw, SW_HDRINVAL, &secno);
    badblkinfo.sw_log_bad[i] = secno;
    atleast_one_entry++;
}

scanline(ln)
char *ln;
{
    char *p = ln;
    int n = 0;

    media.cyl = media.head = media.boff = media.blen = 0;

/* someone did copy&paste - make it more readable */
#define IS_EOLN (*p == '\0' || *p == '\n')
#define IS_NOEOLN (*p != '\0' && *p != '\n')
#define IS_SPACE (*p == ' ' || *p == '\t')
#define IS_NOSPACE (*p != ' ' && *p != '\t')
#define IS_DIGIT (*p >= '0' && *p <= '9')
#define SKIPSP() while (IS_SPACE) p++

    if (IS_EOLN) return 0;
    SKIPSP();
    while (IS_NOSPACE) {
        if (IS_EOLN) return -1;
        if (!IS_DIGIT) return -1;
        media.cyl = media.cyl * 10 + (*p - '0');
        p++;
    }
    SKIPSP();
    while (IS_NOSPACE) {
        if (IS_EOLN) return -1;
        if (!IS_DIGIT) return -1;
        media.head = media.head * 10 + (*p - '0');
        p++;
    }
    SKIPSP();
    while (IS_NOSPACE) {
        if (IS_EOLN) return -1;
        if (!IS_DIGIT) return -1;
        media.boff = media.boff * 10 + (*p - '0');
        p++;
    }
    SKIPSP();
    while (IS_NOSPACE) {
        if (IS_EOLN) {
            if (n) break;
            return -1;
        }
        if (!IS_DIGIT) return -1;
        media.blen = media.blen * 10 + (*p - '0');
        p++; n++;
    }
    if (IS_SPACE) {
        p++;
        while (IS_NOEOLN) {
            if (IS_NOSPACE) return -1;
            p++;
        }
    }
    if (media.cyl==0 && media.head==0 && media.boff==0 && media.blen==0) 
        return 0;
    return 1;
}

extend(nb)
int nb;
{
    int sec, off;

    sec = (media.boff / sw_brutto + 1);
    sec *= sw_brutto;
    off = sec - media.boff;
    if ((nb % sw_brutto) > off ||
        ((nb % sw_brutto) == 0 && (media.boff % sw_brutto) != 0))
        return 1;
    return 0;
}

translate(secno)
int secno;
{
    int tmp;
    
    secno += 2;
    trans.cyl  = secno / SECPERCYL;             /* locate cylinder# */
    trans.head = secno - trans.cyl * SECPERCYL; /* locate sec# in cylinder */
    trans.head /= drivedata.nsec;               /* locate head# */
    tmp = secno % drivedata.nsec;               /* locate sec# in track */
    trans.boff = (tmp * sw_brutto) + 1;         /* brutto start byte off of sec in track */
    trans.blen = (tmp + 1) * sw_brutto;         /* brutto end   byte off of sec in track */
}

validate()
{
    int i;

    for (i = 0; i < MAXBADSEC; i++) {
        if (badblkinfo.sw_log_bad[i] != 0)
            sa_ioctl(rsw, SW_HDRVAL, &badblkinfo.sw_log_bad[i]);
    }
}

sa_swbadfix()
{
    int secno;
    int isave;
    extern char sa_line[];

    printf("Enter disk drive (sw(15), sw(31), sw2(15) or sw2(31)) : ");
    gets(sa_line);
    if ((rsw=sa_open(sa_line, 2)) < 0)
        return;

    isave = iflag;
    iflag = 0;
    if (getdrivedata() != 0) {
        printf("Cannot get drive datas\n");
        return;
    }
    
    if (getbadblkinfo() != 0) {
        printf("Cannot get bad block info\n");
        return;
    }
    
    iflag = isave;
    printf("Enter sector number (decimal) : ");
    gets(sa_line);
    secno = atol(sa_line);
    if (secno < 0 || secno > nettosecs)
        return;

    swbadfix(secno);
    sa_close(rsw);
}